#   @EventListener
#   jdesi 和redisTemplate区别


#1、redis 简介
    REmote DIctionary Server(Redis) 是一个key-value存储系统。
    Redis是一个开源的 C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
    
    它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。
#2、为什么使用redis

    主要是从两个角度去考虑:性能和并发。redis还具备可以做分布式锁，消息队列等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，
    并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。
##性能
    我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。后面的请求就去缓存中读取，使得请求能够迅速响应。

##并发
    在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

#3、redis注意的问题
    (一)缓存和数据库双写一致性问题
    
    (二)缓存雪崩问题
    
    (三)缓存击穿问题
    
    (四)缓存的并发竞争问题
#4、redis为什么这么快
    (一)纯内存操作
    (二)单线程操作，避免了频繁的上下文切换
    (三)采用了非阻塞I/O多路复用机制  https://www.cnblogs.com/skiler/p/6852493.html
#5、从大家熟知的mysql出发来认识redis
     1) 概念：
           关系型数据库的一个常见用法是存储长期的报告数据，并将这些报告数据用作固定时间范围内的聚合数据。
           收集聚合数据的常见做法是：先将各个行插入一个报告表里面， 之后再通过扫描这些行来收集聚合数据， 
           并更新聚合表中巳有的那些行。

     2）mysql的执行过程
        客户端->查询缓存->解析器->预处理器->查询优化器->查询执行引擎->存储引擎->数据
#6、 剖析Redis和memcached之间的区别
  分析三者的区别和为什么越来越多的人抛弃memcached选择redis

  1、作为同款功能的内存缓存产品，redis和memcached各有什么优势

     数据持久化方案

         1）memcached不支持内存数据的持久化操作，所有的数据都以in-memory的形式存储。

         2）redis支持持久化操作。redis提供了两种不同的持久化方法来将数据存储到硬盘里面，
         
            rdb：属于全量数据备份，备份的是数据
            aof：append only if,增量持久化备份，备份的是指令 [如：set key， del key]
     
     缓存数据过期机制 
         1）Memcached 在删除失效主键时也是采用的消极方法，即 Memcached 内部也不会监视主键是否失效，而是在通过 Get访问主键时才会检查其是否已经失效

         2）Redis 定时、定期等多种缓存失效机制，减少内存泄漏

     支持的数据类型
         
         1）Memcached支持单一数据类型,[k,v]

         2）redis支持五种数据类型   
 2、 redis作为数据库和作为内存缓存的两种使用方法
 
        1、redis作为数据库的使用有什么优缺点

            1）优点：
                    没有Scheme约束，数据结构的变更相对容易，一开始确定数据类型，
                    抗压能力强，性能极高，10万/qps
            2）缺点：
                    没有索引，没有外键，缺少int/date等基本数据类型，多条件查询需要通过集合内联(sinter,zinterstore)   和连接间接实现
                    开发效率低，可维护性不佳

        2、redis作为缓存的使用，搭配数据库使用的两种方案

           1）jedis整合使用方案        set key,value ["11","22"]  第一层在缓存进行查询，如果得到数据则直接返回，     
           第二层在数据库进行查询，并且刷新缓存，方便下次查询  ["33,"44"]
           
           2）作为mybatis/hibernate二级缓存使用方案，一级缓存：sqlSession，进程缓存，单次链接有效

