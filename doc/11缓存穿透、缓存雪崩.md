#1、什么是缓存雪崩？你有什么解决方案来防止缓存雪崩？
    
    1、如果缓存【集中】在一段时间内失效，所有的查询都落在数据库上，造成了缓存雪崩。

    2、你有什么解决方案来防止缓存雪崩？

       1、加锁排队   key： whiltList  value：1000w个uid 指定setNx whiltList value nullValue
           mutex互斥锁解决，Redis的SETNX去set一个mutex key，
           当操作返回成功时，再进行load db的操作并回设缓存；
           否则，就重试整个get缓存的方法

       2、数据预热
           缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，
           先查询数据库，然后再将数据缓存的问题!用户直接查询事先被预热的缓存数据!
           可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的key     

       3、双层缓存策略
           C1为原始缓存，C2为拷贝缓存，C1失效时，可以访问C2，C1缓存失效时间设置为短期，C2设置为长期。

       4、定时更新缓存策略
           失效性要求不高的缓存，容器启动初始化加载，采用定时任务更新或移除缓存

       5、设置不同的过期时间，让缓存失效的时间点尽量均匀
#1、什么是缓存穿透？你有什么解决方案来防止缓存穿透？
  
     缓存穿透是指用户查询数据，【在数据库没有】，自然在缓存中也不会有。这样就导致用户查询的时候，
     在缓存中找不到对应key的value，每次都要去数据库再查询一遍，然后返回空(相当于进行了两次
     无用的查询)。这样请求就绕过缓存直接查数据库
     
     1、缓存空值
         如果一个查询返回的数据为空(不管是数据不 存在，还是系统故障)我们仍然把这个空结果进行缓存，但它的过期时间会很短，
         最长不超过五分钟。 通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库    

     2、采用布隆过滤器BloomFilter  优势占用内存空间很小，bit存储。性能特别高。
         将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 
         bitmap 拦截掉，从而避免了对底层存储系统的查询压力

