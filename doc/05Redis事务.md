# 1、 深入浅出剖析传统关系型数据库事务

    1、一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：

        1、为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
        2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

    2、事务的ACID四大特性
        原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行[3]。
        一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束[3]。
        隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行[3]。
        持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中[3]。

    
    3、事务隔离机制： set global transaction isolation level read uncommitted;
       read uncommitted、read committed、repeatable read、serializable
#2、mysql事务隔离机制和MVCC
    简介：传统关系型事务隔离实现过程讲解，图解剖析MVCC（Multiversion Concurrency Control）

    1、 redis事务隔离机制可重复读讲解（repeatable read）

    2、 InnoDB MVCC多版本并发控制功能讲解，
      在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。
    这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，
    用来和查询每行记录的版本号进行比较。
#3、redis事务机制
      
    1、 MULTI 与 EXEC命令
         以 MULTI 开始一个事务，然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令

    2、 DISCARD命令

         DISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 
         最后返回字符串 OK 给客户端， 说明事务已被取消。

    3、WATCH命令

         WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 
         如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。

#4、redis事务与传统关系型事务的比较
    1、 原子性（Atomicity）

        单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。
        如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。
  
    2、 一致性（Consistency）

         入队错误
             在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等，
             那么服务器将向客户端返回一个出错信息， 并且将客户端的事务状态设为 REDIS_DIRTY_EXEC 。

         执行错误
             如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作， 
             那么 Redis 只会将错误包含在事务的结果中， 这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，
             也不会影响后面要执行的事务命令， 所以它对事务的一致性也没有影响。

    3、隔离性（Isolation）

         WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。

    4、持久性（Durability）

         因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，
         所以事务的持久性由 Redis 所使用的持久化模式决定

    

